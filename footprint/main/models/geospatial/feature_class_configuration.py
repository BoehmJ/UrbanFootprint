from footprint.main.lib.functions import remove_keys, merge
from footprint.main.models.geospatial.feature import Feature
from footprint.main.utils.utils import full_module_path

__author__ = 'calthorpe'

class FeatureClassConfiguration(object):

    # For configuration only, only the abstract_class_name is retained
    # to prevent serializing classes
    abstract_class = None
    abstract_class_name = None
    class_name = None
    # Used to hold class-scope attributes. Some will be generated, but you can specify others explicitly and they will be merged together
    class_attrs = {}
    related_class_lookup = {}
    # The scope of the Geography table. Scenarios always scope to the Project geography table, for now
    geography_scope = None
    key = None
    fields = []
    related_fields = []
    # Indicates that the configuration was generated by introspecting a table, rather than by deliberate configuration
    generated = False
    # Indicates that the features should be created from the db_entity's LayerSelection features.
    # The LayerSelection is based on the user who last updated the db_entity (db_entity.updater)
    source_from_origin_layer_selection = False
    # Set to the origin Layer if source_from_origin_layer_selection is True
    # The LayerSelection to use is based on this user and the user whoe is the DbEntity.updater
    origin_layer_id = None
    # The default data_importer for features
    # The default imports based on the url of the db_entity--usually a special database url
    data_importer = None
    # For imported data, the file type, such as shp, json, psql, etc
    import_file_type = None
    # This is only the owning DbEntity for feature_class_configuration of Result DbEntities
    feature_class_owner = None
    source_id_column = None
    # Import from the given db_entity key
    import_from_db_entity_key = None
    # The primary key of the source table when importing. Defaults to 'id'
    primary_key = None
    # The primary key type of the source table when importing. Defaults to 'integer'
    primary_key_type = None
    # Indicates that the Feature table represents a primary geography of the system
    # This means that other Feature tables will form geographic associations to the features
    # based on the type of intersection defined by DbEntity.feature_behavior.intersection property
    primary_geography = None
    # Optional specific fields to import from the import_from_db_entity_key feature table
    import_fields = None
    # Option to only import ids and not all fields. Good for tables that need all the rows of the import_from_db_entity_key table
    # but need the feature attributes to be blank
    import_ids_only = False
    #Option to create an empty table with the schema of the django model
    empty_table = False


    def __init__(self, **kwargs):
        """
            kwargs are the attributes of the class. None are required
        """
        abstract_class_name = full_module_path(kwargs['abstract_class']) if \
                                kwargs.get('abstract_class') else \
                                kwargs.get('abstract_class_name', full_module_path(Feature))
        updated_kwargs = merge(
            remove_keys(kwargs, ['abstract_class']),
            dict(abstract_class_name=abstract_class_name))
        self.__dict__.update(**updated_kwargs)

    @property
    def is_valid(self):
        return self.key and self.abstract_class_name
